#include "Game.h"

void Game::Init() {
	m_MS.Init();
	saiinit();
	meshinf = fop.ReadFile(meshinf);

	//CM.SetPol(&polyinf);
	//CM.SetMat(&meshinf);
	//CM.init();


	for (int i = 0; i < smax; i++) {
		for (int j = 0; j < smax; j++) {
			for (int k = 0; k < smax; k++) {
				if (j == smax-1) { s[i][j][k].display = 1; }
				else { s[i][j][k].display = 0; }
				s[i][j][k].xyz = D3DXVECTOR3(-2 * i + (smax - 1),-2* j + (smax - 1), -2 * k + (smax - 1));
			}
		}
	}

	static int num = 0;
	num = meshinf.size();
	for (int i = 0; i < smax; i++) {
		for (int j = 0; j < smax; j++) {
			for (int k = 0; k < smax; k++) {

				if (s[i][j][k].display == 1) {
					s[i][j][k].meshnum = num;
					num++;
					Mesh *lpm = new Mesh();
					//if (num % 2 == 0) {
						lpm->mname = "kuroro.x";
					//}
					//else { lpm->mname = "siroro.x"; }
					lpm->Init();
					lpm->SetPos(s[i][j][k].xyz);
					lpm->Update();
					meshinf.push_back(lpm);
				}
				else {
					s[i][j][k].meshnum = -999;
				}
			}
		}
	}
	c.x = smax/2;
	c.y = smax-2;
	c.z = smax/2;
	c.meshnum = num;
	s[c.x][c.y][c.z].meshnum = c.meshnum;
	s[c.x][c.y][c.z].display = 1;
	Mesh *lpm = new Mesh();
	lpm->mname = "saikoro.x";
	lpm->Init();
	lpm->SetPos(s[c.x][c.y][c.z].xyz);
	lpm->Update();
	meshinf.push_back(lpm);
	//照準テクスチャ
	LoadText("Texture/cross.bmp", 32, 32, D3DCOLOR_XRGB(255, 255, 255));

	//スプライト
	D3DXCreateSprite(cdg.lpD3DDevice, &lpCross);	//照準
	lpCross->OnResetDevice();

	D3DXMatrixIdentity(&miden);
}
void Game::Draw() {

	//cdg.lpD3DDevice->SetTransform(D3DTS_WORLD, &miden);

	//m_MS.SetTransformWorld(&meshinf[0]->mWorld);
	//m_MS.DrawMesh(meshinf[0]);
	cdg.lpD3DDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
	//cdg.lpD3DDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CW);

	for (int i = 0; i <1; i++) {
		meshinf[i]->Render();
	}
	for (int i = 0; i < smax; i++) {
		for (int j = 0; j < smax; j++) {
			for (int k = 0; k < smax; k++) {
				if (s[i][j][k].display == 1) {
					meshinf[s[i][j][k].meshnum]->Render();
				}
			}
		}
	}
	//meshinf[c.meshnum]->Render();
	cdg.lpD3DDevice->SetFVF(FVF_VERTEX);

	//cdg.lpD3DDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
	cdg.lpD3DDevice->SetRenderState(D3DRS_LIGHTING, TRUE);

}
void Game::Update() {
	//key
	static int mmin;
	float Dis=-1;
	std::vector<int > hitlist;
	std::vector<float > Dislist;
	std::vector<float > mDislist;

	if (debagflg == 0) {
		ddt.SetChar("CPos(%.2f,%.2f,%.2f)\n", CPos);
	ddt.SetChar("CLook(%.2f,%.2f,%.2f)\n", CLook);
	ddt.SetChar("CHead(%.2f,%.2f,%.2f)\n", CHead);

	if (GetAsyncKeyState('T') & 0x8000) {
		D3DXQUATERNION q(0, 0, 0, 1); // 単位クォータニオン'q'を生成
		D3DXMATRIX TurnMat; // 回転行列
		D3DXMATRIX mat;	//平行移動行列
		D3DXVECTOR3 NAxis(1, 0, 0); // 任意の中心軸
									//何もしない行列を作る
		D3DXMatrixIdentity(&TurnMat);
		//ｚ軸を中心に 45度　回転するクォータニオン'q'を生成
		D3DXQuaternionRotationAxis(&q, &NAxis, D3DXToRadian(5));
		//D3DXQuaternionRotationYawPitchRoll()
		//クォータニオンをマトリックスに変換
		D3DXMatrixRotationQuaternion(&TurnMat, &q);
		//行列をかける（回転させた後、行列'mat'で平行移動させる）
		//TurnMat *= mat;
		meshinf[c.meshnum]->mWorld = TurnMat*meshinf[c.meshnum]->mWorld;
		
	}
		if (GetAsyncKeyState('F') & 0x8000) {
			D3DXQUATERNION q(0, 0, 0, 1); // 単位クォータニオン'q'を生成
			D3DXMATRIX TurnMat; // 回転行列
			D3DXMATRIX mat;	//平行移動行列
			D3DXVECTOR3 NAxis(0, 0, 1); // 任意の中心軸
			//何もしない行列を作る
			D3DXMatrixIdentity(&mat);
			D3DXMatrixIdentity(&TurnMat);
			//ｚ軸を中心に 45度　回転するクォータニオン'q'を生成
			D3DXQuaternionRotationAxis(&q, &NAxis, D3DXToRadian(5));
			//クォータニオンをマトリックスに変換
			D3DXMatrixRotationQuaternion(&TurnMat, &q);
			//行列をかける（回転させた後、行列'mat'で平行移動させる）
			//TurnMat *= mat;
			meshinf[c.meshnum]->mWorld = TurnMat*meshinf[c.meshnum]->mWorld;
		}
		if (GetAsyncKeyState('G') & 0x8000) {
			D3DXQUATERNION q(0, 0, 0, 1); // 単位クォータニオン'q'を生成
			D3DXMATRIX TurnMat; // 回転行列
			D3DXMATRIX mat;	//平行移動行列
			D3DXVECTOR3 NAxis(1, 0, 0); // 任意の中心軸
										//何もしない行列を作る
			D3DXMatrixIdentity(&mat);
			D3DXMatrixIdentity(&TurnMat);

			//ｚ軸を中心に 45度　回転するクォータニオン'q'を生成
			D3DXQuaternionRotationAxis(&q, &NAxis, D3DXToRadian(-5));
			//クォータニオンをマトリックスに変換
			D3DXMatrixRotationQuaternion(&TurnMat, &q);
			//行列をかける（回転させた後、行列'mat'で平行移動させる）
			//TurnMat *= mat;
			meshinf[c.meshnum]->mWorld = TurnMat*meshinf[c.meshnum]->mWorld;
		}
		if (GetAsyncKeyState('H') & 0x8000) {
			D3DXQUATERNION q(0, 0, 0, 1); // 単位クォータニオン'q'を生成
			D3DXMATRIX TurnMat; // 回転行列
			D3DXMATRIX mat;	//平行移動行列
			D3DXVECTOR3 NAxis(0, 0, 1); // 任意の中心軸
										//何もしない行列を作る
			D3DXMatrixIdentity(&mat);
			D3DXMatrixIdentity(&TurnMat);

			//ｚ軸を中心に 45度　回転するクォータニオン'q'を生成
			D3DXQuaternionRotationAxis(&q, &NAxis, D3DXToRadian(-5));
			//クォータニオンをマトリックスに変換
			D3DXMatrixRotationQuaternion(&TurnMat, &q);
			//行列をかける（回転させた後、行列'mat'で平行移動させる）
			//TurnMat *= mat;
			meshinf[c.meshnum]->mWorld = TurnMat*meshinf[c.meshnum]->mWorld;
		}
		if (GetAsyncKeyState('K') & 0x8000) {
			D3DXQUATERNION q(0, 0, 0, 1); // 単位クォータニオン'q'を生成
			D3DXMATRIX TurnMat; // 回転行列
			D3DXMATRIX mat;	//平行移動行列
			D3DXVECTOR3 NAxis(0, 1, 0); // 任意の中心軸
										//何もしない行列を作る
			D3DXMatrixIdentity(&mat);
			D3DXMatrixIdentity(&TurnMat);
			//x座標に３、ｚ座標に３移動する行列
			D3DXMatrixTranslation(&mat, 3, 0, 3);
			//ｚ軸を中心に 45度　回転するクォータニオン'q'を生成
			D3DXQuaternionRotationAxis(&q, &NAxis, D3DXToRadian(45));
			//クォータニオンをマトリックスに変換
			D3DXMatrixRotationQuaternion(&TurnMat, &q);
			//行列をかける（回転させた後、行列'mat'で平行移動させる）
			//TurnMat *= mat;
			meshinf[c.meshnum]->mWorld = TurnMat*meshinf[c.meshnum]->mWorld;
		}
		if (GetAsyncKeyState('L') & 0x8000) {
			D3DXQUATERNION q(0, 0, 0, 1); // 単位クォータニオン'q'を生成
			D3DXMATRIX TurnMat; // 回転行列
			D3DXMATRIX mat;	//平行移動行列
			D3DXVECTOR3 NAxis(0, 1, 0); // 任意の中心軸
										//何もしない行列を作る
			D3DXMatrixIdentity(&mat);
			D3DXMatrixIdentity(&TurnMat);
			//x座標に３、ｚ座標に３移動する行列
			D3DXMatrixTranslation(&mat, 3, 0, 3);
			//ｚ軸を中心に 45度　回転するクォータニオン'q'を生成
			D3DXQuaternionRotationAxis(&q, &NAxis, D3DXToRadian(-45));
			//クォータニオンをマトリックスに変換
			D3DXMatrixRotationQuaternion(&TurnMat, &q);
			//行列をかける（回転させた後、行列'mat'で平行移動させる）
			//TurnMat *= mat;
			meshinf[c.meshnum]->mWorld = TurnMat*meshinf[c.meshnum]->mWorld;
		}
		if (GetAsyncKeyState('Z') & 0x8000) {
			AnimeFrame += 0.01f;
			if (AnimeFrame > 1) {
				AnimeFrame = 1;
			}
			AnimeProc();
			
		}

		if (GetAsyncKeyState('X') & 0x8000) {
			AnimeFrame -= 0.01f;
			if (AnimeFrame < 0) {
				AnimeFrame = 0;
			}
			AnimeProc();

		}
		//meshinf[c.meshnum]->mWorld = mNow;
		if (GetAsyncKeyState('I')) {
			for (int i = 0; i < meshinf.size(); i++) {
				delete meshinf[i];
			}
			meshinf.clear();

			meshinf = fop.ReadFile(meshinf);
			CM.SetPol(&polyinf);
			CM.SetMat(&meshinf);
			CM.init();
		}
		CM.Update(&CPos, &CLook, &CHead); 
	
		ddt.SetChar("meshinf.size%d\n",meshinf.size());

		CLook = CLook - CPos  ;
		//Meshの当たり判定
		for (int i = 0; i < meshinf.size(); i++) {
			D3DXMATRIX mInv;
			D3DXMatrixInverse(&mInv, NULL, &meshinf[i]->mWorld);
			D3DXVECTOR3 LocalPos, LocalVec;
			D3DXVec3TransformCoord(&LocalPos, &CPos, &mInv);
			D3DXVec3TransformNormal(&LocalVec, &CLook, &mInv);
			BOOL Hit;
			float WallDis = -1;
			D3DXIntersect(meshinf[i]->xMesh.lpMesh, &LocalPos, &LocalVec, &Hit, NULL, NULL, NULL, &WallDis, NULL, NULL);
			if (Hit) {

			}else {
			
			}
			mDislist.push_back(WallDis);
		}
	
		CLook = CPos + CLook;
		mmin = minDis(mDislist, mDislist.size());
		ddt.SetChar("mmin %d", mmin);
		ddt.SetChar("mDislist.size %u\n", mDislist.size());

		if (mmin != -1) {
			ddt.SetChar("x:%.2f", meshinf[mmin]->mWorld._41);
			ddt.SetChar("y:%.2f", meshinf[mmin]->mWorld._42);
			ddt.SetChar("z:%.2f\n", meshinf[mmin]->mWorld._43);
			ddt.SetChar("name:%s", &meshinf[mmin]->mname);
		}
	}
	if (GetAsyncKeyState(VK_SHIFT) & 0x8000) {
		if (GetAsyncKeyState('1') & 0x8000) {
			CPos = D3DXVECTOR3(0.0f, 5.0f, -13.0f);
			CLook = D3DXVECTOR3(0.0f, -8.0f, 0.0f);
			CHead = D3DXVECTOR3(0.0f, 1.0f, 0.0f);
			debagflg = 1;
			
		}
		if (GetAsyncKeyState('0') & 0x8000) {
			debagflg = 0;
		}
		if (GetAsyncKeyState('2') & 0x8000) {
			CPos = D3DXVECTOR3(0.0f, 5.0f, -13.0f);
			CLook = D3DXVECTOR3(0.0f, -8.0f, 0.0f);
			CHead = D3DXVECTOR3(0.0f, 1.0f, 0.0f);
			debagflg = 2;
		}
	}
	if (debagflg == 1) {
		/*for (int i = 0; i < smax; i++) {
			for (int j = 0; j < smax; j++) {
				for (int k = 0; k < smax; k++) {
					ddt.SetChar("%d ", s[i][j][k].meshnum);
				}	
				ddt.SetChar("\n");
			}
		ddt.SetChar("   ");
		}*/
		if (GetAsyncKeyState(VK_DOWN) & 0x8000) {
			if (keyaniflg == 0) {
				if (c.z < smax - 1) {
					int num = tatesai[0];
					tatesai[0] = tatesai[3];
					tatesai[3] = tatesai[2];
					tatesai[2] = tatesai[1];
					tatesai[1] = num;

					yokosai[0] = tatesai[0];
					yokosai[2] = tatesai[2];
					setsai(tatesai, yokosai);

					s[c.x][c.y][c.z].display = 0;
					s[c.x][c.y][c.z].meshnum = -999;
					//D3DXMATRIX sRot;
					//D3DXMatrixTranslation(&mStart, s[c.x][c.y][c.z].xyz.x, s[c.x][c.y][c.z].xyz.y, s[c.x][c.y][c.z].xyz.z);
					//D3DXMatrixRotationYawPitchRoll(&sRot, D3DXToRadian(keyaniroty), D3DXToRadian(keyanirotx), D3DXToRadian(keyanirotz));
					//D3DXMatrixRotationYawPitchRoll(&sRot, D3DXToRadian(0), D3DXToRadian(0), D3DXToRadian(0));
					c.z += 1;
					s[c.x][c.y][c.z].display = 1;
					s[c.x][c.y][c.z].meshnum = c.meshnum;

					D3DXQUATERNION q(0, 0, 0, 1); // 単位クォータニオン'q'を生成
					D3DXMATRIX TurnMat; // 回転行列
										//何もしない行列を作る
					D3DXMatrixIdentity(&TurnMat);

					mStart = meshinf[c.meshnum]->mWorld;
					//meshinf[c.meshnum]->mWorld = TurnMat*meshinf[c.meshnum]->mWorld;

					keyanirotx -= 90;
					D3DXQuaternionRotationYawPitchRoll(&q, D3DXToRadian(keyaniroty), D3DXToRadian(keyanirotx), D3DXToRadian(keyanirotz));
					//クォータニオンをマトリックスに変換
					D3DXMatrixRotationQuaternion(&TurnMat, &q);

					meshinf[c.meshnum]->SetPos(s[c.x][c.y][c.z].xyz.x, s[c.x][c.y][c.z].xyz.y, s[c.x][c.y][c.z].xyz.z);
					meshinf[c.meshnum]->Update();
					mEnd = TurnMat*meshinf[c.meshnum]->mWorld;
					mNow = mStart;
					AnimeFrame = 0;
					keyaniflg = 1;
					if (sai[0] == 1) {

					}
					if (sai[0] == 3) {

					}
				}
			}
		}
		if (GetAsyncKeyState(VK_RIGHT) & 0x8000) {
			if (keyaniflg == 0) {
				if (c.x > 0) {
					int num = yokosai[0];
					yokosai[0] = yokosai[3];
					yokosai[3] = yokosai[2];
					yokosai[2] = yokosai[1];
					yokosai[1] = num;

					tatesai[0] = yokosai[0];
					tatesai[2] = yokosai[2];
					setsai(tatesai, yokosai);

					s[c.x][c.y][c.z].display = 0;
					s[c.x][c.y][c.z].meshnum = -999;
					
					c.x -= 1;
					s[c.x][c.y][c.z].display = 1;
					s[c.x][c.y][c.z].meshnum = c.meshnum;
		
					D3DXQUATERNION q(0, 0, 0, 1); // 単位クォータニオン'q'を生成
					D3DXMATRIX TurnMat; // 回転行列
										//何もしない行列を作る
					D3DXMatrixIdentity(&TurnMat);

					mStart = meshinf[c.meshnum]->mWorld;
					meshinf[c.meshnum]->mWorld = TurnMat*meshinf[c.meshnum]->mWorld;
					if (sai[1] == 3) { keyanirotz -= 90; }
					else if (sai[1] == 4) { keyanirotz += 90; }
					else if (sai[1] == 1) { }
					else {  }
					
					D3DXQuaternionRotationYawPitchRoll(&q, D3DXToRadian(keyaniroty), D3DXToRadian(keyanirotx), D3DXToRadian(keyanirotz));
					//クォータニオンをマトリックスに変換
					D3DXMatrixRotationQuaternion(&TurnMat, &q);

					meshinf[c.meshnum]->SetPos(s[c.x][c.y][c.z].xyz.x, s[c.x][c.y][c.z].xyz.y, s[c.x][c.y][c.z].xyz.z);
					meshinf[c.meshnum]->Update();
					mEnd = TurnMat*meshinf[c.meshnum]->mWorld;
					mNow = mStart;
					AnimeFrame = 0;
					keyaniflg = 1;

				}
			}
		}
		if (GetAsyncKeyState(VK_UP) & 0x8000) {
			if (keyaniflg == 0) {
				if (c.z > 0) {

					int num = tatesai[0];
					tatesai[0] = tatesai[1];
					tatesai[1] = tatesai[2];
					tatesai[2] = tatesai[3];
					tatesai[3] = num;

					yokosai[0] = tatesai[0];
					yokosai[2] = tatesai[2];
					setsai(tatesai, yokosai);

					D3DXMATRIX mtmp;
					D3DXMatrixTranslation(&mtmp, s[c.x][c.y][c.z].xyz.x, s[c.x][c.y][c.z].xyz.y, s[c.x][c.y][c.z].xyz.z);


					s[c.x][c.y][c.z].display = 0;
					s[c.x][c.y][c.z].meshnum = -999;

					c.z -= 1;
					s[c.x][c.y][c.z].display = 1;
					s[c.x][c.y][c.z].meshnum = c.meshnum;
					
					D3DXQUATERNION q(0, 0, 0, 1); // 単位クォータニオン'q'を生成
					D3DXMATRIX TurnMat; // 回転行列
					//何もしない行列を作る
					D3DXMatrixIdentity(&TurnMat);
					
					mStart =mtmp;
					//meshinf[c.meshnum]->mWorld = TurnMat*meshinf[c.meshnum]->mWorld;

					keyanirotx += 90;


					D3DXQuaternionRotationYawPitchRoll(&q, D3DXToRadian(keyaniroty), D3DXToRadian(keyanirotx), D3DXToRadian(keyanirotz));
					//クォータニオンをマトリックスに変換
					D3DXMatrixRotationQuaternion(&TurnMat, &q);
					D3DXMatrixIdentity(&mtmp);
					D3DXMatrixTranslation(&mtmp,s[c.x][c.y][c.z].xyz.x, s[c.x][c.y][c.z].xyz.y, s[c.x][c.y][c.z].xyz.z);
					
					mEnd = TurnMat*mtmp;
					mNow = mStart;
					AnimeFrame = 0;
					keyaniflg = 1;



				}
			}
		}
		if (GetAsyncKeyState(VK_LEFT) & 0x8000) {
			if (keyaniflg == 0) {
				if (c.x < smax - 1) {
					int num = yokosai[0];
					yokosai[0] = yokosai[1];
					yokosai[1] = yokosai[2];
					yokosai[2] = yokosai[3];
					yokosai[3] = num;

					tatesai[0] = yokosai[0];
					tatesai[2] = yokosai[2];
					setsai(tatesai, yokosai);

					s[c.x][c.y][c.z].display = 0;
					s[c.x][c.y][c.z].meshnum = -999;
					
					c.x += 1;
					s[c.x][c.y][c.z].display = 1;
					s[c.x][c.y][c.z].meshnum = c.meshnum;
					D3DXQUATERNION q(0, 0, 0, 1); // 単位クォータニオン'q'を生成
					D3DXMATRIX TurnMat; // 回転行列
										//何もしない行列を作る
					D3DXMatrixIdentity(&TurnMat);

					mStart = meshinf[c.meshnum]->mWorld;
					meshinf[c.meshnum]->mWorld = TurnMat*meshinf[c.meshnum]->mWorld;

					if (sai[1] == 3) { keyanirotz += 90; }
					else if (sai[1] == 4) { keyanirotz -= 90; }
					else if (sai[1] == 1) {  }
					else {  }
					D3DXQuaternionRotationYawPitchRoll(&q, D3DXToRadian(keyaniroty), D3DXToRadian(keyanirotx), D3DXToRadian(keyanirotz));
					//クォータニオンをマトリックスに変換
					D3DXMatrixRotationQuaternion(&TurnMat, &q);

					meshinf[c.meshnum]->SetPos(s[c.x][c.y][c.z].xyz.x, s[c.x][c.y][c.z].xyz.y, s[c.x][c.y][c.z].xyz.z);
					meshinf[c.meshnum]->Update();
					mEnd = TurnMat*meshinf[c.meshnum]->mWorld;
					mNow = mStart;
					AnimeFrame = 0;
					keyaniflg = 1;

				}
			}
		}

		if (keyaniflg == 1) {
			AnimeFrame += 0.01f;
			if (AnimeFrame > 1) {
				AnimeFrame = 1;
				keyaniflg = 0;
				meshinf[c.meshnum]->SetPos(s[c.x][c.y][c.z].xyz);
				meshinf[c.meshnum]->Update();
				//D3DXMatrixIdentity(&mRot);
				if (sai[0] == 1) {
	
					meshinf[c.meshnum]->mname = "saikoro.x";
					meshinf[c.meshnum]->Init();
				
					meshinf[c.meshnum]->Update();
					//meshinf[c.meshnum]->mWorld = TurnMat*meshinf[c.meshnum]->mWorld;
					keyanirotx = keyaniroty = keyanirotz = 0;
				}
				if (sai[0] == 3) {
	
					meshinf[c.meshnum]->mname = "saikoro3.x";
					meshinf[c.meshnum]->Init();
					meshinf[c.meshnum]->SetRot(0, 0, 0);
					meshinf[c.meshnum]->Update();
					//meshinf[c.meshnum]->mWorld = TurnMat*meshinf[c.meshnum]->mWorld;
					keyanirotx = keyaniroty = keyanirotz = 0;
				}

			}
			AnimeProc();
			meshinf[c.meshnum]->mWorld = mNow;
		}
		ddt.SetChar("mname%s\n", &meshinf[c.meshnum]->mname);

		for (int i = 0; i < 4; i++) {
			ddt.SetChar("tatesai[%d]", i);
			ddt.SetChar(":%d    ", tatesai[i]);
			ddt.SetChar("yokosai[%d]", i);
			ddt.SetChar(":%d\n", yokosai[i]);
		}
		for (int i = 0; i < 6; i++) {
			ddt.SetChar("sai[%d]", i);
			ddt.SetChar(":%d\n", sai[i]);
		}

		ddt.SetChar("keyanirotx:%.2f\n", keyanirotx);
		ddt.SetChar("keyaniroty:%.2f\n",keyaniroty);
		ddt.SetChar("keyanirotz:%.2f\n", keyanirotz);

		ddt.SetChar("c.x:%d\n", c.x);
		ddt.SetChar("c.y:%d\n", c.y);
		ddt.SetChar("c.z:%d\n", c.z);

	}
	if (debagflg == 2) {
		static int rotatex=0, rotatey=0, rotatez=0;
		if (keyaniflg == 0) {
			if (GetAsyncKeyState(VK_UP) & 0x8000) {

				//ddt.SetChar("up");
				int num = tatesai[0];
				tatesai[0] = tatesai[1];
				tatesai[1] = tatesai[2];
				tatesai[2] = tatesai[3];
				tatesai[3] = num;

				yokosai[0] = tatesai[0];
				yokosai[2] = tatesai[2];
				setsai(tatesai, yokosai);


				AnimeFrame = 0;
				keyaniflg = 1;

			}
			if (GetAsyncKeyState(VK_DOWN) & 0x8000) {

				//ddt.SetChar("down");
				int num = tatesai[0];
				tatesai[0] = tatesai[3];
				tatesai[3] = tatesai[2];
				tatesai[2] = tatesai[1];
				tatesai[1] = num;

				yokosai[0] = tatesai[0];
				yokosai[2] = tatesai[2];
				setsai(tatesai, yokosai);
				AnimeFrame = 0;
				keyaniflg = 1;
			}
			if (GetAsyncKeyState(VK_RIGHT) & 0x8000) {

				//ddt.SetChar("right");
				int num = yokosai[0];
				yokosai[0] = yokosai[3];
				yokosai[3] = yokosai[2];
				yokosai[2] = yokosai[1];
				yokosai[1] = num;

				tatesai[0] = yokosai[0];
				tatesai[2] = yokosai[2];
				setsai(tatesai, yokosai);
				AnimeFrame = 0;
				keyaniflg = 1;
			}
			if (GetAsyncKeyState(VK_LEFT) & 0x8000) {
				//ddt.SetChar("left");
				int num = yokosai[0];
				yokosai[0] = yokosai[1];
				yokosai[1] = yokosai[2];
				yokosai[2] = yokosai[3];
				yokosai[3] = num;

				tatesai[0] = yokosai[0];
				tatesai[2] = yokosai[2];
				setsai(tatesai, yokosai);
				AnimeFrame = 0;
				keyaniflg = 1;
			}
		}		
		if (keyaniflg == 1) {
			//D3DXMATRIX mtmp;
			//D3DXMatrixRotationYawPitchRoll(&mtmp, D3DXToRadian(rotatey), D3DXToRadian(rotatex), D3DXToRadian(rotatez));
			//meshinf[c.meshnum]->SetRot(rotatex, rotatey, rotatez);
			//meshinf[c.meshnum]->Update();
			//mStart = meshinf[c.meshnum]->mWorld;
			if (sai[0] == 1) { rotatex = 0; }
			if (sai[0] == 2) { rotatez = 90; }
			if (sai[0] == 3) { rotatex = 90; }
			if (sai[0] == 4) { rotatex = -90; }
			if (sai[0] == 5) { rotatez = -90; }
			if (sai[0] == 6) { rotatex = 180; }
			if (sai[1] == 1) { rotatey = 0; }
			if (sai[1] == 2) { rotatey = 90; }
			if (sai[1] == 3) { rotatey = 0; }

			if (sai[5] == 2) { rotatez = 0; }
			
			//D3DXMatrixRotationYawPitchRoll(&mtmp, D3DXToRadian(rotatey), D3DXToRadian(rotatex), D3DXToRadian(rotatez));
			meshinf[c.meshnum]->SetRot(rotatex, rotatey, rotatez);
			meshinf[c.meshnum]->Update();
			rotatey = rotatez = rotatex = 0;

	/*		mEnd = meshinf[c.meshnum]->mWorld;
			mNow = mStart;*/
			keyaniflg = 0;
		}

		if (keyaniflg == 2) {
			AnimeFrame += 0.1f;
			if (AnimeFrame > 1) {
				AnimeFrame = 1;
				keyaniflg = 0;
				meshinf[c.meshnum]->SetPos(s[c.x][c.y][c.z].xyz);
				meshinf[c.meshnum]->Update();
				//D3DXMatrixIdentity(&mRot);

			}
			AnimeProc();
			meshinf[c.meshnum]->mWorld = mNow;
		}

		for (int i = 0; i < 4; i++) {
			ddt.SetChar("tatesai[%d]", i);
			ddt.SetChar(":%d    ", tatesai[i]);
			ddt.SetChar("yokosai[%d]", i);
			ddt.SetChar(":%d\n", yokosai[i]);
		}
		for (int i = 0; i < 6; i++) {
			ddt.SetChar("sai[%d]", i);
			ddt.SetChar(":%d\n", sai[i]);
		}

	}

}

void Game::Release() {
	m_MS.Release();
	lpCrosshair->Release();
	for (int i = 0; i < polyinf.size(); i++) {
		delete polyinf[i];
	}
	polyinf.clear();
	for (int i = 0; i < meshinf.size(); i++) {
		delete meshinf[i];
	}
	meshinf.clear();
	
}

void Game::DrawFrame() {
	if (fps.CheckFps() <= 0) {
		return;
	}
	ddt.SetChar("FPS:%d\n", fps.fps);
	//レイを向いている方向に発射、スプライトで目標＋表示、レイが当たったポリゴンの情報をデバックで表示

	// 更新処理
	Game::Update();

	// 描画開始
	cdg.lpD3DDevice->BeginScene();

	// バックバッファと Z バッファをクリア
	cdg.lpD3DDevice->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, D3DCOLOR_XRGB(0, 0, 255), 1.0f, 0);

	D3DXMATRIX mView, mProj;

	// 視点行列の設定
	D3DXMatrixLookAtLH(&mView,
		&CPos,
		&CLook,
		&CHead
	);

	// 投影行列の設定
	D3DXMatrixPerspectiveFovLH(&mProj, D3DXToRadian(60), (float)SCRW / (float)SCRH, 1.0f, 300.0f);

	//行列設定
	cdg.lpD3DDevice->SetTransform(D3DTS_VIEW, &mView);
	cdg.lpD3DDevice->SetTransform(D3DTS_PROJECTION, &mProj);
	
	//shader
	cdg.GetDev()->GetTransform(D3DTS_VIEW, &mView);
	cdg.GetDev()->GetTransform(D3DTS_PROJECTION, &mProj);
	D3DXMATRIX mCam;
	D3DXMatrixInverse(&mCam, nullptr, &mView);

	D3DLIGHT9 light;
	cdg.lpD3DDevice->GetLight(0, &light);

	m_MS.SetTransformView(&mView);
	m_MS.SetTransformProj(&mProj);
	m_MS.SetDirectionalLight(&light);
	m_MS.SetCamPos((D3DXVECTOR3*)&mCam._41);
	// 描画処理

	Game::Draw();

	if (debagflg == 0) {
	D3DXMatrixTranslation(&mCrossWorld, SCRW / 2, SCRH / 2, 0.0f);
	RECT rc = { 0,0,32,32 };
	D3DXVECTOR3 vec = D3DXVECTOR3(16.0f, 16.0f, 0.0f);
	//Beagin
	lpCross->Begin(D3DXSPRITE_ALPHABLEND);
	lpCross->SetTransform(&mCrossWorld);
	lpCross->Draw(lpCrosshair, &rc, &vec, NULL, D3DCOLOR_ARGB(255, 255, 255, 255));
	lpCross->End();
	}
	ddt.Draw();
	ddt.Bufferreset();


	// 描画終了
	cdg.lpD3DDevice->EndScene();

	// バックバッファをプライマリバッファにコピー
	cdg.lpD3DDevice->Present(NULL, NULL, NULL, NULL);
}